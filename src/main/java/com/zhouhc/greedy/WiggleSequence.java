package com.zhouhc.greedy;

import java.util.Arrays;

/**
 * q376_摆动序列
 */
public class WiggleSequence {


    public static void main(String[] args) {
//        int[] nums = new int[]{1, 7, 4, 9, 2, 5};
//        int[] nums = new int[]{1,17,5,10,13,15,10,5,16,8};
//        int[] nums = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9};
//        int[] nums = new int[]{1, 1, 1, 1, 1, 1};
        int[] nums = new int[]{33,53,12,64,50,41,45,21,97,35,47,92,39,0, 93,55,40,46,69,42,6,95,51,68,72,9,32,84,34,64,6,2,26,98, 3,43,30,60,3,68,82,9,97,19,27,98,99,4,30,96,37,9,78,43,64, 4,65,30,84,90,87,64,18,50,60,1,40,32,48,50,76,100,57,29,63, 53,46,57,93,98,42,80,82,9,41,55,69,84,82,79,30,79,18,97,67, 23,52,38,74,15};
//        int[] nums = new int[]{33, 53, 12, 64, 50, 41, 45, 21};
        System.out.println(Arrays.toString(nums) + " : " + findWayByTrend(nums));
    }

    /**
     * 自己的想法 :
     *   存在序列 x1,x2,x3...摆动序列，如果xi 与 xi-1
     *   不满足摆动要求，否则舍弃 xi ,知道找到 下一个 xj 和 xi-1满足
     *   摆动序列的需求, 只要第一个序列足够贪心就好
     *  时间复杂度 : O(n),空间复杂度为 O(1)
     *  这种思想是错误的.....
     *  记录它的主要目的是为了和正确的思想比较
     *
     *  官方的给的解释(自己缩减了很多的,最好还是看官方原本的解释)
     *    先说一个现象：摆动序列会形成一上一下的折线，存在着波峰，
     *    波谷的说法，只要一个区间内波峰 + 波谷数量更多,那就是
     *    最优解，...->波峰->波谷->波峰...，波峰和波谷必须
     *    紧接着出现，题目更关注的是上升或者下降的趋势，而不是
     *    在出现连续的波峰或者波谷的时候，考虑使用哪个元素作用
     *    波峰或者波谷，从上升或者下降的趋势来说，他们其实是一样的
     *    选取任意一个就行了
     *
     *    时间复杂度 : O(n) 空间复杂度为: O(1)
     *    贪心算法一定要找普遍的规律，这样才能满足贪心算法
     *    就像本题关注的是上升或者下降的趋势，而不是上一次
     *    的波峰或者波谷在哪里。
     */
    public static int findWayByTrend(int[] nums) {
        //空判断
        if (nums == null)
            return 0;
        //对于数量小于2的数组，直接返回对应的长度就行了
        if (nums.length < 2)
            return nums.length;
        //开始正常寻找波峰,波谷元素,使用与前一个元素的区间值进行计算
        int diff = nums[1] - nums[0];
        //结果统计
        int result = diff != 0 ? 2 : 1;
        //关注上升或者下降的趋势
        for (int i = 2; i < nums.length; i++) {
            int comp = nums[i] - nums[i - 1];
            if ((comp > 0 && diff <= 0) || (comp < 0 && diff >= 0)) {
                result++;
                diff = comp;
            }
        }
        //结果返回
        return result;
    }
}
